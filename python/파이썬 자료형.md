# python - 리스트 자료형

- 문자열 포매팅

  - ```python
    >>> "I eat %d apples." % 3
    'I eat 3 apples.'
    ```

    숫자 바로 대입 `%d`에 % 3을 대입

  - ```python
    >>> "I eat %s apples." % "five"
    'I eat five apples.'
    ```

    문자열 대입 `%s`에 % five 을 대입

  - ```python
    >>> age = 30
    >>> f'나는 내년이면 {age+1}살이 된다.'
    '나는 내년이면 31살이 된다.'
    ```

    f 문자열 포매팅은 위와 같이 name, age와 같은 변수 값을 생성한 후에 그 값을 참조할 수 있다. 또한 f 문자열 포매팅은 표현식을 지원하기 때문에 다음과 같은 것도 가능하다.

  - ```python
    >>> d = {'name':'홍길동', 'age':30}
    >>> f'나의 이름은 {d["name"]}입니다. 나이는 {d["age"]}입니다.'
    '나의 이름은 홍길동입니다. 나이는 30입니다.'
    ```

    딕셔너리는 f 문자열 포매팅에서 다음과 같이 사용할 수 있다.

    > ※ 딕셔너리는 Key와 Value라는 것을 한 쌍으로 갖는 자료형이다. 02-5에서 자세히 알아본다.

  - ```python
    >>> a = "Life is too short"
    >>> a.index('t')
    8
    ```

    인덱스 : 위치 알려주는 함수

    ```python
    >>> a = "Life is too short"
    >>> a.replace("Life", "Your leg")
    'Your leg is too short'
    ```

    문자열 바꾸는 함수

    ```python
    >>> a = [1, 2, ['a', 'b', ['Life', 'is']]]
    >>> a[2][2][0]
    'Life'
    ```

    삼중 구조 인덱싱 참고. 접근법 알아두기.

    ```python
    >>> a = [1, 2, 3, ['a', 'b', 'c'], 4, 5]
    >>> a[2:5]
    [3, ['a', 'b', 'c'], 4]
    >>> a[3][:2]
    ['a', 'b']
    ```

    슬라이싱 [:2] 을 출력할 시 세번째 요소까지 보여주는 것이 아닌 [0:1] 값만 출력한다는 것을 명심

  - str 함수는 정수나 실수를 문자열의 형태로 바꾸어 주는 파이썬의 내장 함수이다

    ```python
    >>> a = [1, 2, 3]
    >>> a.append(4)
    >>> a
    [1, 2, 3, 4]
    ```

    append 함수의 한 예시. 

    ```python
    >>> a = [1, 4, 3, 2]
    >>> a.sort()
    >>> a
    [1, 2, 3, 4]
    ```

    sort 함수 : 리스트 정렬 (알파벳도 가능) <> reverse 함수 : 리스트 역순 정렬

    a.index(4) : 값은 1 (4를 찾아 위치를 알려줌)  a.insert(a, b) : a번째 자리에 b값을 넣음.

    a.remove(x) : 첫번째로 나오는 x값 제거. 중복되는 값이 있어도 첫번째거만 지움.

    a.pop() : 맨 마지막 요소를 돌려주고 그 후 요소 삭제

    a.pop(x) : x번째 요소를 돌려주고 그 후 요소 삭제 > x번째 출력해보면 값이 삭제되어 있음

    a.count(x) : x의 개수 세기. 갯수 만큼 돌려줌.

    ```python
    >>> a = [1,2,3]
    >>> a.extend([4,5])
    >>> a
    [1, 2, 3, 4, 5]
    >>> b = [6, 7]
    >>> a.extend(b)
    >>> a
    [1, 2, 3, 4, 5, 6, 7]
    ```

    리스트 확장 extend(x) 에서 x에는 리스트만 올 수 있다.

    a.extend([4,5])는 a += [4,5] 와 동일하다

# 튜플 자료형

> 튜플은 값이 변경, 삭제가 절대 안 된다. 사칙연산도 불가능.
>
> 반면 리스트 자료형(a=[])은 가능하다.
>
> 인덱싱과 슬라이싱은 가능하다.

```python
>>> t1 = (1, 2, 'a', 'b')
>>> t1[0]
1
>>> t1[3]
'b' # 인덱싱 예.
```

```python
>>> t1 = (1, 2, 'a', 'b')
>>> t1[1:]
(2, 'a', 'b') # 슬라이싱 예
```



# 딕셔너리 자료형

```python
>>> a[3] = [1,2,3]
>>> a
{1: 'a', 2: 'b', 'name': 'pey', 3: [1, 2, 3]}
```

Key는 3, Value [1,2,3]을 가지는 한 쌍이 추가됨.

> del a[key] 입력하면 key에 해당하는 {key : value}쌍이 삭제됨.

```python
>>> a = {1:'a', 1:'b'}
>>> a
{1: 'b'}
```

key값이 중복되면 하나를 제외한 나머지 key는 무시됨. 주의할 것!

> key값에는 변하는 수가 들어갈 수 없다. 즉 튜플 자료형은 변경,삭제가 불가능하므로 허용이 되지만
>
> 변하는 값인 리스트 자료형은 key값으로 부적절하다.

```python
>>> a = {'name': 'pey', 'phone': '0119993323', 'birth': '1118'}
>>> a.keys()
dict_keys(['name', 'phone', 'birth'])
```

> a.keys() 는 a의 key값인 name,phone,birth 을 모아서 dict_keys 객체를 돌려준다.

```python
>>> for k in a.keys():
...    print(k)
...
name
phone
birth
```

> a.keys() 의 key값들을 k라는 변수를 생성하여 print함수 안에 대입하여 값들을 보여주는 모습.
>
> for in 반복문 구조를 익혀두자. keys 와 마찬가지로 values함수도 존재함.

```python
>>> a.items()
dict_items([('name', 'pey'), ('phone', '0119993323'), ('birth', '1118')])
```

> key, value 쌍 얻기(items) and key,value 쌍 모두 지우기(clear)

```python
>>> a = {'name':'pey', 'phone':'0119993323', 'birth': '1118'}
>>> a.get('name')
'pey'
>>> a.get('phone')
'0119993323'
```

> get : key로 value값 얻기

```python
>>> a.get('foo', 'bar') // get(x,'디폴트 값')
'bar'
```

> 딕셔너리 안에 찾으려는 Key 값이 없을 경우, foo 에 해당하는 값이 없을 경우 디폴트 값인 bar를 돌려준다.

```python
>>> a = {'name':'pey', 'phone':'0119993323', 'birth': '1118'}
>>> 'name' in a
True
>>> 'email' in a
False
```

# 집합(set) 자료형

```python
>>> s1 = set([1,2,3])
>>> s1
{1, 2, 3}
```

> 비어 있는 집합 자료형은 s = set() 로 만들 수 있다. ()안에 리스트를 입력하거나 문자열을 입력할 수 도 있다.
>
> 특징 : 중복을 허용하지 않는다. 순서가 없다. >> 인덱싱(indexing)으로 값을 얻을 수 없다.
>
> 값을 얻으려면 리스트나 튜플로 변환 후 가능하다.

```python
>>> s1 = set([1,2,3])  // 집합 자료형(set)
>>> l1 = list(s1)      // 리스트 자료형으로 바꿈 인덱싱하기 위해.
>>> l1				   // set은 인덱싱이 안되니까.
[1, 2, 3]
>>> l1[0]
1
>>> t1 = tuple(s1)		// 집합 자료형을 튜플 자료형으로 바꿈
>>> t1					// 인덱싱 하기 위해.
(1, 2, 3)
>>> t1[0]
1
```

- 교집합

```python
>>> s1 & s2 // s1.intersection(s2) = s2.intersection(s1) 세개 다 교집합 구하는 법.
{4, 5, 6}
```

- 합집합

```python
>>> s1 | s2   // s1.union(s2) 같은 방법. 중복된 값이 있을 경우 하나만 표현됨.
{1, 2, 3, 4, 5, 6, 7, 8, 9}
```

- 차집합

```python
>>> s1 - s2 // s1.difference(s2) 같은 방법. s1에서 s2에 있는 값만 빠지는 것을 명심.
{1, 2, 3}
>>> s2 - s1 // s2에서 s1에 있는 값만 빠진다.
{8, 9, 7}
```

- 값 추가하기

```python
>>> s1 = set([1, 2, 3])
>>> s1.add(4) // 값 하나 추가할 때 쓰는 함수 여러개 추가할 땐 update([4,5,6])
>>> s1
{1, 2, 3, 4}
```

> 값 제거할 땐 remove(2) >> s1 = {1,3,4} 



# 불(bool) 자료형

> True = 참 // 불 자료형은 무조건 대문자로 시작.
>
> False = 거짓 // 파이썬의 예약어로 true,false 같이 사용하면 안되고 첫 문자를 항상 대문자로 사용해야 한다.

```python
>>> type(a)
<class 'bool'>
>>> type(b)
<class 'bool'>
```

- 자료형의 참과 거짓
  - 값이 있으면 참(True) 값이 없으면 거짓(False)    >>>  (" ",[ ], ( ), { }) 모두 비어 있으므로 False

```python
>>> a = [1, 2, 3, 4]
>>> while a: // a 에는 조건문
...     print(a.pop()) // 수행할 문장
...
4    					// pop()함수는 마지막 요소를 끄집어 내고 삭제시키는 함수.
3						// a의 값이 다 사라지고 값이 없어지면 False가 되므로
2						// 더 이상 실행되지 않는다.
1
```

```python
>>> if []:						// []비어 있으므로 거짓.
...     print("참")				// else 문이 실행되어 거짓이 출력.
... else:						// 값이 있다면 참(True)
...     print("거짓")
...
거짓
```

```python
>>> bool([1,2,3])
True
>>> bool([])
False
>>> bool(0)
False
>>> bool(3)
True
```



# 자료형의 값을 저장하는 공간, 변수

> 변수는 객체를 가리키는 것, 객체란 자료형(리스트,튜플,딕셔너리,집합,불)을 말한다.
>
> 변수란 자료형을 담고 있는 주소라고 할 수 있다.

```python
>>> a = [1, 2, 3]
>>> b = a[:]		// b = a 이렇게 사용 시 같은 주소를 사용하게 됨.
>>> a[1] = 4		// 즉 a의 값이 바뀌면 b도 같이 바뀜.
>>> a				// b = a[:] 리스트 전체를 가리키는 [:]를 이용하여 복사할 시
[1, 4, 3]			// 다른 주소를 사용하게 되어 a의 값이 바뀌어도 b의 값이 안 변함.
>>> b				// from copy import copy
[1, 2, 3]			// b = copy(a) // 위와 같이 다른 주소 사용하여 복사하는 방식
```

> b is a 실행 시 False값 나옴. 값이 같아도 주소가 다르기 때문.

```python
>>> a = 3
>>> b = 5
>>> a, b = b, a
>>> a
5			// a변수에 b값(value)가 들어갔다.
>>> b
3			// b변수에 a값(value)가 들어감.
```

